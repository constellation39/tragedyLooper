# 游戏阶段处理器 (Phase Handler)

`phasehandler` 包负责管理《惨案循环》游戏引擎中的游戏流程。它将游戏分解为一系列离散的 **阶段 (Phases)**，每个阶段代表游戏中的一个特定时间点或一组玩家行动。这种设计使得游戏逻辑更易于管理、扩展和测试。

## 核心概念

- **Phase (阶段)**: `Phase` 是一个接口，定义了游戏流程中一个独立单元的行为。每个阶段都实现了处理玩家行动 (`HandleAction`)、游戏事件 (`HandleEvent`) 和超时 (`HandleTimeout`) 的方法。
- **Manager (管理器)**: `Manager` 负责驱动整个游戏流程。它持有对当前阶段的引用，并处理从一个阶段到下一个阶段的转换。它确保了阶段的生命周期方法（`Enter`, `Exit`）被正确调用，并管理阶段的超时。
- **GameEngine (游戏引擎接口)**: `phasehandler` 通过一个 `GameEngine` 接口与游戏的核心逻辑进行交互。这允许阶段代码触发事件、查询游戏状态、检查条件和执行效果，而无需与引擎的具体实现紧密耦合。
- **Registry (注册表)**: 所有的 `Phase` 实现都在一个全局注册表中注册。这使得 `Manager` 可以通过 `GamePhase` 枚举类型动态地获取和转换到任何一个阶段。

## 游戏流程 (Game Flow)

游戏从 `SetupPhase` 开始，然后按照预定义的顺序依次经过各个阶段。主要的流程如下：

1.  **Setup & MastermindSetup**: 游戏初始化，主谋进行初始设置。
2.  **Loop Start**: 一个新的循环开始。
3.  **Day Start**: 一个新的天开始。
4.  **Card Play (Mastermind & Protagonist)**: 玩家（先是主谋，然后是主角）打出他们的手牌。
5.  **Card Reveal**: 所有被打出的牌被揭示。
6.  **Card Effects**: 解析所有卡牌的效果（例如移动、状态变化）。
7.  **Abilities**: 玩家有机会使用角色的能力。
8.  **Incidents**: 检查并触发当天发生的事件。
9.  **Day End**: 检查循环的结束条件。如果循环未结束，则返回到 **Day Start**。
10. **Loop End**: 循环结束。检查游戏是否结束。如果游戏未结束，则返回到 **Loop Start**。
11. **Protagonist Guess**: 在特定条件下，主角可以尝试猜测谜底。
12. **Game Over**: 游戏结束，宣布胜利者。

```mermaid
graph TD
    A["开始游戏"] --> B{"选择剧本"};
    B --> C["设置游戏: 根据剧本初始化角色,地点,计数器"];
    C --> D{"循环开始"};
    D --> E["每日流程"];

    E --> F["主谋打牌 (3张, 面朝下)"];
    F --> G["主角打牌 (每人1张, 面朝下, 顺时针, 领队开始)"];
    G --> H["揭示所有卡牌"];
    H --> I["卡牌结算阶段"];

    I --> I1["1. 禁止移动卡结算"];
    I1 --> I2["2. 移动卡结算"];
    I2 --> I3["3. 其他禁止卡结算 (偏执, 善意, 阴谋)"];
    I3 --> I4["4. 其他卡牌效果结算 (偏执+/-, 善意+/-, 阴谋+/-)"];
    I4 --> J{"能力激活阶段"};

    J --> K["主谋能力激活 (总是优先于主角)"];
    K --> L["主角善意能力激活 (领队选择)"];
    L --> M{"事件检查与触发"};

    M --> N{"是否满足强制事件条件?"};
    N -- 是 --> O["强制触发事件 (主谋必须触发)"];
    O --> P["应用事件后果 (例如: 角色死亡)"];
    P --> Q{"检查循环失败条件"};
    N -- 否 --> Q;

    Q --> R{"循环是否失败 (例如: 关键人物死亡)?"};
    R -- 是 --> S["主谋揭示: '谁死了' (不揭示死因/凶手)"];
    S --> T{"是否达到最大循环数?"};
    T -- 否 --> U["重置游戏组件 (保留主角知识)"];
    U --> D; %% 返回循环开始
    T -- 是 --> V{"最终猜测阶段"};

    R -- 否 --> W{"是否所有失败条件都已阻止?"};
    W -- 是 --> X["主角获胜"];
    W -- 否 --> E; %% 继续下一个循环日

    V --> Y["主角进行最终猜测 (所有角色真实身份)"];
    Y --> Z{"最终猜测是否正确?"};
    Z -- 是 --> X; %% 主角获胜
    Z -- 否 --> AA["主谋获胜"];

    X --> End["游戏结束"];
    AA --> End;
```

## 文件结构

- `interfaces.go`: 定义了核心的 `Phase` 和 `GameEngine` 接口。
- `manager.go`: 实现了驱动游戏流程的 `Manager`。
- `registry.go`: 提供了注册和获取 `Phase` 实现的机制。
- `*_phase.go` (例如, `card_play.go`, `abilities.go`): 每个文件实现了游戏的一个特定阶段。文件名清晰地表明了它所管理的阶段。

## 如何添加一个新的阶段

1.  创建一个新的 `your_phase_name.go` 文件。
2.  定义一个新的结构体，并实现 `Phase` 接口的所有方法。
3.  在文件的 `init()` 函数中，使用 `RegisterPhase()` 将你的新阶段注册到注册表中。
4.  在现有阶段的逻辑中，添加转换到你新阶段的代码。