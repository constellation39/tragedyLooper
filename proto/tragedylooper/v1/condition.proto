syntax = "proto3";

package tragedylooper.v1;

import "tragedylooper/v1/common.proto";
import "tragedylooper/v1/enums.proto";

option go_package = "github.com/constellation39/tragedyLooper/pkg/proto/v1";

// Condition defines a condition for triggering rules, events, and effects.
// It uses a oneof to ensure that only one type of condition can be set at a time.
// For logical negation, use a CompoundCondition with the NOT operator.
message Condition {
  // The type of the condition.
  oneof condition_type {
    // A stat condition.
    StatCondition stat_condition = 1;
    // A location condition.
    LocationCondition location_condition = 2;
    // A role condition.
    RoleCondition role_condition = 3;
    // A trait condition.
    TraitCondition trait_condition = 4;
    // A day condition.
    DayCondition day_condition = 5;
    // A player condition.
    PlayerCondition player_condition = 6;
    // A compound condition (AND/OR/NOT).
    CompoundCondition compound_condition = 7;
    // A phase condition.
    PhaseCondition phase_condition = 8;
    // An event history condition.
    EventHistoryCondition event_history_condition = 9;
    // A location character count condition.
    LocationCharacterCountCondition location_character_count_condition = 11;
  }
}

// EventHistoryCondition defines a condition based on past game events.
message EventHistoryCondition {
  // The type of event to look for.
  GameEventType event_type = 1;
  // How many days into the past to look. 0 means today, 1 means today and yesterday, etc.
  int32 lookback_days = 2;
  // Optional: Further filter by the character involved in the event.
  TargetSelector event_target = 3;
  // The number of times the event must have occurred.
  int32 count = 4;
  // The comparator for the count.
  Comparator comparator = 5;

  // Optional: A filter for the event payload.
  oneof event_filter {
    StatAdjustedEventFilter stat_adjusted_event_filter = 6;
  }
}

// StatAdjustedEventFilter provides a filter for StatAdjustedEvent.
message StatAdjustedEventFilter {
  // Optional: The stat type to match.
  optional StatType stat_type = 1;
  // Optional: The amount to compare against.
  optional int32 amount = 2;
  // Optional: The comparator for the amount.
  optional Comparator amount_comparator = 3;
}

// PhaseCondition defines a condition based on the current game phase.
message PhaseCondition {
  // The comparator to use.
  Comparator comparator = 1;
  // The target game phase.
  GamePhase phase = 2;
}

// CompoundCondition defines a combination of multiple conditions.
// For NOT, provide exactly one sub-condition.
message CompoundCondition {
  // The operator to use when combining conditions.
  enum Operator {
    // Unspecified operator.
    OPERATOR_UNSPECIFIED = 0;
    // The logical AND operator.
    OPERATOR_AND = 1;
    // The logical OR operator.
    OPERATOR_OR = 2;
    // The logical NOT operator.
    OPERATOR_NOT = 3;
  }
  // The logical operator to use.
  Operator operator = 1;
  // A list of sub-conditions.
  repeated Condition sub_conditions = 2;
}

// StatCondition defines a condition based on a character's stats.
message StatCondition {
  // The target character selector.
  TargetSelector target = 1;
  // The type of stat to check.
  StatType stat_type = 2;
  // The comparator to use.
  Comparator comparator = 3;
  // The value to compare against.
  int32 value = 4;
  // Optional: A second target to compare against.
  // If set, the condition compares the stat of 'target' with the stat of 'target_to_compare'.
  TargetSelector target_to_compare = 5;
}

// LocationCondition defines a condition that checks if a character is at a specific location.
// To check if a character is NOT at a location, use a CompoundCondition with the NOT operator.
message LocationCondition {
  // The target character selector.
  TargetSelector target = 1;
  // The target location.
  LocationType location = 2;
}

// LocationCharacterCountCondition defines a condition based on the number of characters at a location.
message LocationCharacterCountCondition {
  // The target location.
  LocationType location = 1;
  // The comparator to use.
  Comparator comparator = 2;
  // The number of characters to compare against.
  int32 count = 3;
}

// RoleCondition defines a condition based on a character's role.
// To check if a character does NOT have a role, use a CompoundCondition with the NOT operator.
message RoleCondition {
  // The target character selector.
  TargetSelector target = 1;
  // The role to check.
  int32 role_id = 2;
}

// TraitCondition defines a condition based on a character's traits.
// To check if a character does NOT have a trait, use a CompoundCondition with the NOT operator.
message TraitCondition {
  // The target character selector.
  TargetSelector target = 1;
  // The target trait.
  string trait = 2;
}

// DayCondition defines a condition based on the current day.
message DayCondition {
  // The comparator to use.
  Comparator comparator = 1;
  // The target day.
  int32 day = 2;
}

// PlayerCondition defines a condition based on a player's state.
message PlayerCondition {
  // The target player role.
  PlayerRole player_role = 1;
  // Extensible: e.g., check if the player has used a certain card.
}

// TargetSelector defines a dynamic target for conditions or effects.
// It uses a oneof to ensure that only one type of selector can be set at a time.
// When a selector can potentially match multiple characters (e.g., all_characters_at_location),
// and it is used in a context that evaluates a condition (like StatCondition),
// the condition is considered true if *any* of the matched characters satisfy the condition.
message TargetSelector {
  oneof selector {
    // A specific character by ID.
    int32 specific_character = 1;
    // The character that triggered the event.
    Empty triggering_character = 2;
    // The culprit of the event.
    Empty culprit = 3;
    // The victim of the event.
    Empty victim = 4;
    // Any character with a specific role.
    int32 character_with_role_id = 5;
    // All characters at a specific location.
    LocationType all_characters_at_location = 6;
    // The user of the action (card or ability).
    Empty action_user = 7;
    // The target of the action (card or ability).
    Empty action_target = 8;
    // All characters.
    Empty all_characters = 9;
  }
}
