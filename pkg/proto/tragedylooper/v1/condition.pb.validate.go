// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: tragedylooper/v1/condition.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.ConditionType.(type) {
	case *Condition_StatCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStatCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "StatCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "StatCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStatCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "StatCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_LocationCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLocationCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "LocationCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "LocationCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLocationCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "LocationCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_RoleCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRoleCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "RoleCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "RoleCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRoleCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "RoleCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_TraitCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTraitCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "TraitCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "TraitCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTraitCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "TraitCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_DayCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDayCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "DayCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "DayCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDayCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "DayCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_PlayerCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPlayerCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "PlayerCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "PlayerCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPlayerCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "PlayerCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_CompoundCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCompoundCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "CompoundCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "CompoundCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCompoundCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "CompoundCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_PhaseCondition:
		if v == nil {
			err := ConditionValidationError{
				field:  "ConditionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPhaseCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "PhaseCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "PhaseCondition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPhaseCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "PhaseCondition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on PhaseCondition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PhaseCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PhaseCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PhaseConditionMultiError,
// or nil if none found.
func (m *PhaseCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *PhaseCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Comparator

	// no validation rules for Phase

	if len(errors) > 0 {
		return PhaseConditionMultiError(errors)
	}

	return nil
}

// PhaseConditionMultiError is an error wrapping multiple validation errors
// returned by PhaseCondition.ValidateAll() if the designated constraints
// aren't met.
type PhaseConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PhaseConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PhaseConditionMultiError) AllErrors() []error { return m }

// PhaseConditionValidationError is the validation error returned by
// PhaseCondition.Validate if the designated constraints aren't met.
type PhaseConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PhaseConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PhaseConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PhaseConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PhaseConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PhaseConditionValidationError) ErrorName() string { return "PhaseConditionValidationError" }

// Error satisfies the builtin error interface
func (e PhaseConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPhaseCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PhaseConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PhaseConditionValidationError{}

// Validate checks the field values on CompoundCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CompoundCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompoundCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompoundConditionMultiError, or nil if none found.
func (m *CompoundCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *CompoundCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Operator

	for idx, item := range m.GetSubConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompoundConditionValidationError{
						field:  fmt.Sprintf("SubConditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompoundConditionValidationError{
						field:  fmt.Sprintf("SubConditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompoundConditionValidationError{
					field:  fmt.Sprintf("SubConditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CompoundConditionMultiError(errors)
	}

	return nil
}

// CompoundConditionMultiError is an error wrapping multiple validation errors
// returned by CompoundCondition.ValidateAll() if the designated constraints
// aren't met.
type CompoundConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompoundConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompoundConditionMultiError) AllErrors() []error { return m }

// CompoundConditionValidationError is the validation error returned by
// CompoundCondition.Validate if the designated constraints aren't met.
type CompoundConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompoundConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompoundConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompoundConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompoundConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompoundConditionValidationError) ErrorName() string {
	return "CompoundConditionValidationError"
}

// Error satisfies the builtin error interface
func (e CompoundConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompoundCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompoundConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompoundConditionValidationError{}

// Validate checks the field values on StatCondition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatConditionMultiError, or
// nil if none found.
func (m *StatCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *StatCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatConditionValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StatType

	// no validation rules for Comparator

	// no validation rules for Value

	if len(errors) > 0 {
		return StatConditionMultiError(errors)
	}

	return nil
}

// StatConditionMultiError is an error wrapping multiple validation errors
// returned by StatCondition.ValidateAll() if the designated constraints
// aren't met.
type StatConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatConditionMultiError) AllErrors() []error { return m }

// StatConditionValidationError is the validation error returned by
// StatCondition.Validate if the designated constraints aren't met.
type StatConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatConditionValidationError) ErrorName() string { return "StatConditionValidationError" }

// Error satisfies the builtin error interface
func (e StatConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatConditionValidationError{}

// Validate checks the field values on LocationCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LocationCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocationCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LocationConditionMultiError, or nil if none found.
func (m *LocationCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *LocationCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LocationConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LocationConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LocationConditionValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Location

	// no validation rules for IsAtLocation

	// no validation rules for IsAlone

	// no validation rules for NotAlone

	if len(errors) > 0 {
		return LocationConditionMultiError(errors)
	}

	return nil
}

// LocationConditionMultiError is an error wrapping multiple validation errors
// returned by LocationCondition.ValidateAll() if the designated constraints
// aren't met.
type LocationConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocationConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocationConditionMultiError) AllErrors() []error { return m }

// LocationConditionValidationError is the validation error returned by
// LocationCondition.Validate if the designated constraints aren't met.
type LocationConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocationConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocationConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocationConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocationConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocationConditionValidationError) ErrorName() string {
	return "LocationConditionValidationError"
}

// Error satisfies the builtin error interface
func (e LocationConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocationCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocationConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocationConditionValidationError{}

// Validate checks the field values on RoleCondition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleConditionMultiError, or
// nil if none found.
func (m *RoleCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleConditionValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HasRole

	if len(errors) > 0 {
		return RoleConditionMultiError(errors)
	}

	return nil
}

// RoleConditionMultiError is an error wrapping multiple validation errors
// returned by RoleCondition.ValidateAll() if the designated constraints
// aren't met.
type RoleConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleConditionMultiError) AllErrors() []error { return m }

// RoleConditionValidationError is the validation error returned by
// RoleCondition.Validate if the designated constraints aren't met.
type RoleConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleConditionValidationError) ErrorName() string { return "RoleConditionValidationError" }

// Error satisfies the builtin error interface
func (e RoleConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleConditionValidationError{}

// Validate checks the field values on TraitCondition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TraitCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraitCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TraitConditionMultiError,
// or nil if none found.
func (m *TraitCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *TraitCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TraitConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TraitConditionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TraitConditionValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Trait

	// no validation rules for HasTrait

	if len(errors) > 0 {
		return TraitConditionMultiError(errors)
	}

	return nil
}

// TraitConditionMultiError is an error wrapping multiple validation errors
// returned by TraitCondition.ValidateAll() if the designated constraints
// aren't met.
type TraitConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraitConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraitConditionMultiError) AllErrors() []error { return m }

// TraitConditionValidationError is the validation error returned by
// TraitCondition.Validate if the designated constraints aren't met.
type TraitConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraitConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraitConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraitConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraitConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraitConditionValidationError) ErrorName() string { return "TraitConditionValidationError" }

// Error satisfies the builtin error interface
func (e TraitConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraitCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraitConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraitConditionValidationError{}

// Validate checks the field values on DayCondition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DayCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DayCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DayConditionMultiError, or
// nil if none found.
func (m *DayCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *DayCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Comparator

	// no validation rules for Day

	if len(errors) > 0 {
		return DayConditionMultiError(errors)
	}

	return nil
}

// DayConditionMultiError is an error wrapping multiple validation errors
// returned by DayCondition.ValidateAll() if the designated constraints aren't met.
type DayConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DayConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DayConditionMultiError) AllErrors() []error { return m }

// DayConditionValidationError is the validation error returned by
// DayCondition.Validate if the designated constraints aren't met.
type DayConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DayConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DayConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DayConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DayConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DayConditionValidationError) ErrorName() string { return "DayConditionValidationError" }

// Error satisfies the builtin error interface
func (e DayConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDayCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DayConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DayConditionValidationError{}

// Validate checks the field values on PlayerCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PlayerCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PlayerConditionMultiError, or nil if none found.
func (m *PlayerCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlayerRole

	if len(errors) > 0 {
		return PlayerConditionMultiError(errors)
	}

	return nil
}

// PlayerConditionMultiError is an error wrapping multiple validation errors
// returned by PlayerCondition.ValidateAll() if the designated constraints
// aren't met.
type PlayerConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerConditionMultiError) AllErrors() []error { return m }

// PlayerConditionValidationError is the validation error returned by
// PlayerCondition.Validate if the designated constraints aren't met.
type PlayerConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerConditionValidationError) ErrorName() string { return "PlayerConditionValidationError" }

// Error satisfies the builtin error interface
func (e PlayerConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerConditionValidationError{}

// Validate checks the field values on TargetSelector with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TargetSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TargetSelector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TargetSelectorMultiError,
// or nil if none found.
func (m *TargetSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *TargetSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Selector.(type) {
	case *TargetSelector_SpecificCharacter:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for SpecificCharacter
	case *TargetSelector_TriggeringCharacter:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for TriggeringCharacter
	case *TargetSelector_Culprit:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Culprit
	case *TargetSelector_Victim:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Victim
	case *TargetSelector_CharacterWithRole:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for CharacterWithRole
	case *TargetSelector_AllCharactersAtLocation:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for AllCharactersAtLocation
	case *TargetSelector_AbilityUser:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for AbilityUser
	case *TargetSelector_AbilityTarget:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for AbilityTarget
	case *TargetSelector_AllCharacters:
		if v == nil {
			err := TargetSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for AllCharacters
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TargetSelectorMultiError(errors)
	}

	return nil
}

// TargetSelectorMultiError is an error wrapping multiple validation errors
// returned by TargetSelector.ValidateAll() if the designated constraints
// aren't met.
type TargetSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TargetSelectorMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TargetSelectorMultiError) AllErrors() []error { return m }

// TargetSelectorValidationError is the validation error returned by
// TargetSelector.Validate if the designated constraints aren't met.
type TargetSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TargetSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TargetSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TargetSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TargetSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TargetSelectorValidationError) ErrorName() string { return "TargetSelectorValidationError" }

// Error satisfies the builtin error interface
func (e TargetSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTargetSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TargetSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TargetSelectorValidationError{}
