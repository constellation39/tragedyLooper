// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.31.1
// source: tragedylooper/v1/script.proto

package v1

import (
	_ "cuelang.org/cueproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Script defines the configuration for a tragedy looper script.
type ScriptConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the script.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the script.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// A description of the script.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Main plot configurations. ID range: 1000-1999
	MainPlots map[int32]*PlotConfig `protobuf:"bytes,4,rep,name=main_plots,json=mainPlots,proto3" json:"main_plots,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Sub plot configurations. ID range: 2000-2999
	SubPlots map[int32]*PlotConfig `protobuf:"bytes,5,rep,name=sub_plots,json=subPlots,proto3" json:"sub_plots,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Role configurations. ID range: 3000-3999
	Roles map[int32]*RoleConfig `protobuf:"bytes,6,rep,name=roles,proto3" json:"roles,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Incident configurations. ID range: 4000-4999
	Incidents map[int32]*IncidentConfig `protobuf:"bytes,7,rep,name=incidents,proto3" json:"incidents,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Character configurations. ID range: 5000-5999
	Characters map[int32]*CharacterConfig `protobuf:"bytes,8,rep,name=characters,proto3" json:"characters,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Mastermind card configurations. ID range: 6000-6999
	MastermindCards map[int32]*CardConfig `protobuf:"bytes,9,rep,name=mastermind_cards,json=mastermindCards,proto3" json:"mastermind_cards,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Protagonist card configurations. ID range: 7000-7999
	ProtagonistCards map[int32]*CardConfig `protobuf:"bytes,10,rep,name=protagonist_cards,json=protagonistCards,proto3" json:"protagonist_cards,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of script configurations. ID range: 8000-8999
	ScriptModels  map[int32]*ScriptModel `protobuf:"bytes,11,rep,name=script_models,json=scriptModels,proto3" json:"script_models,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptConfig) Reset() {
	*x = ScriptConfig{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptConfig) ProtoMessage() {}

func (x *ScriptConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptConfig.ProtoReflect.Descriptor instead.
func (*ScriptConfig) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{0}
}

func (x *ScriptConfig) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *ScriptConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ScriptConfig) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ScriptConfig) GetMainPlots() map[int32]*PlotConfig {
	if x != nil {
		return x.MainPlots
	}
	return nil
}

func (x *ScriptConfig) GetSubPlots() map[int32]*PlotConfig {
	if x != nil {
		return x.SubPlots
	}
	return nil
}

func (x *ScriptConfig) GetRoles() map[int32]*RoleConfig {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *ScriptConfig) GetIncidents() map[int32]*IncidentConfig {
	if x != nil {
		return x.Incidents
	}
	return nil
}

func (x *ScriptConfig) GetCharacters() map[int32]*CharacterConfig {
	if x != nil {
		return x.Characters
	}
	return nil
}

func (x *ScriptConfig) GetMastermindCards() map[int32]*CardConfig {
	if x != nil {
		return x.MastermindCards
	}
	return nil
}

func (x *ScriptConfig) GetProtagonistCards() map[int32]*CardConfig {
	if x != nil {
		return x.ProtagonistCards
	}
	return nil
}

func (x *ScriptConfig) GetScriptModels() map[int32]*ScriptModel {
	if x != nil {
		return x.ScriptModels
	}
	return nil
}

// ScriptConfig defines the configuration for a specific script.
type ScriptModel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Private information for the script.
	PrivateInfo *PrivateInfo `protobuf:"bytes,1,opt,name=private_info,json=privateInfo,proto3" json:"private_info,omitempty"`
	// Public information for the script.
	PublicInfo    *PublicInfo `protobuf:"bytes,2,opt,name=public_info,json=publicInfo,proto3" json:"public_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptModel) Reset() {
	*x = ScriptModel{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptModel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptModel) ProtoMessage() {}

func (x *ScriptModel) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptModel.ProtoReflect.Descriptor instead.
func (*ScriptModel) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{1}
}

func (x *ScriptModel) GetPrivateInfo() *PrivateInfo {
	if x != nil {
		return x.PrivateInfo
	}
	return nil
}

func (x *ScriptModel) GetPublicInfo() *PublicInfo {
	if x != nil {
		return x.PublicInfo
	}
	return nil
}

// PrivateInfo defines the private information for a script.
type PrivateInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The main plot of the script.
	MainPlot *PlotConfig `protobuf:"bytes,1,opt,name=main_plot,json=mainPlot,proto3" json:"main_plot,omitempty"`
	// A list of sub plots for the script.
	SubPlots []*PlotConfig `protobuf:"bytes,2,rep,name=sub_plots,json=subPlots,proto3" json:"sub_plots,omitempty"`
	// A map of characters in the script.
	Characters map[int32]*CharacterConfig `protobuf:"bytes,3,rep,name=characters,proto3" json:"characters,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of incidents in the script.
	Incidents     map[int32]*IncidentConfig `protobuf:"bytes,4,rep,name=incidents,proto3" json:"incidents,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrivateInfo) Reset() {
	*x = PrivateInfo{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrivateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrivateInfo) ProtoMessage() {}

func (x *PrivateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrivateInfo.ProtoReflect.Descriptor instead.
func (*PrivateInfo) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{2}
}

func (x *PrivateInfo) GetMainPlot() *PlotConfig {
	if x != nil {
		return x.MainPlot
	}
	return nil
}

func (x *PrivateInfo) GetSubPlots() []*PlotConfig {
	if x != nil {
		return x.SubPlots
	}
	return nil
}

func (x *PrivateInfo) GetCharacters() map[int32]*CharacterConfig {
	if x != nil {
		return x.Characters
	}
	return nil
}

func (x *PrivateInfo) GetIncidents() map[int32]*IncidentConfig {
	if x != nil {
		return x.Incidents
	}
	return nil
}

// PublicInfo defines the public information for a script.
type PublicInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the script configuration.
	ScriptConfigId int32 `protobuf:"varint,1,opt,name=script_config_id,json=scriptConfigId,proto3" json:"script_config_id,omitempty"`
	// Game rules.
	// The number of loops in the game.
	LoopCount int32 `protobuf:"varint,2,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	// The number of days per loop.
	DaysPerLoop int32 `protobuf:"varint,3,opt,name=days_per_loop,json=daysPerLoop,proto3" json:"days_per_loop,omitempty"`
	// Whether players can discuss information.
	CanDiscuss bool `protobuf:"varint,4,opt,name=can_discuss,json=canDiscuss,proto3" json:"can_discuss,omitempty"`
	// Special rules.
	// A map of special incidents.
	SpecialIncidents map[int32]*IncidentConfig `protobuf:"bytes,5,rep,name=special_incidents,json=specialIncidents,proto3" json:"special_incidents,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of scheduled incidents.
	ScheduledIncidents map[int32]*IncidentConfig `protobuf:"bytes,6,rep,name=scheduled_incidents,json=scheduledIncidents,proto3" json:"scheduled_incidents,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PublicInfo) Reset() {
	*x = PublicInfo{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicInfo) ProtoMessage() {}

func (x *PublicInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicInfo.ProtoReflect.Descriptor instead.
func (*PublicInfo) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{3}
}

func (x *PublicInfo) GetScriptConfigId() int32 {
	if x != nil {
		return x.ScriptConfigId
	}
	return 0
}

func (x *PublicInfo) GetLoopCount() int32 {
	if x != nil {
		return x.LoopCount
	}
	return 0
}

func (x *PublicInfo) GetDaysPerLoop() int32 {
	if x != nil {
		return x.DaysPerLoop
	}
	return 0
}

func (x *PublicInfo) GetCanDiscuss() bool {
	if x != nil {
		return x.CanDiscuss
	}
	return false
}

func (x *PublicInfo) GetSpecialIncidents() map[int32]*IncidentConfig {
	if x != nil {
		return x.SpecialIncidents
	}
	return nil
}

func (x *PublicInfo) GetScheduledIncidents() map[int32]*IncidentConfig {
	if x != nil {
		return x.ScheduledIncidents
	}
	return nil
}

// RoleConfig defines the configuration for a role.
type RoleConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the role.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the role.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The limit of characters that can have this role.
	Limit int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// A map of abilities for this role.
	Abilities map[int32]*AbilityConfig `protobuf:"bytes,4,rep,name=abilities,proto3" json:"abilities,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Defines the character's goodwill status.
	// 0: normal, 1: ignore goodwill, 2: always ignore goodwill.
	GoodwillRule int32 `protobuf:"varint,5,opt,name=goodwill_rule,json=goodwillRule,proto3" json:"goodwill_rule,omitempty"`
	// Defines if the character can be made invincible.
	CanBeInvincible bool `protobuf:"varint,6,opt,name=can_be_invincible,json=canBeInvincible,proto3" json:"can_be_invincible,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RoleConfig) Reset() {
	*x = RoleConfig{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoleConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoleConfig) ProtoMessage() {}

func (x *RoleConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoleConfig.ProtoReflect.Descriptor instead.
func (*RoleConfig) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{4}
}

func (x *RoleConfig) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *RoleConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RoleConfig) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *RoleConfig) GetAbilities() map[int32]*AbilityConfig {
	if x != nil {
		return x.Abilities
	}
	return nil
}

func (x *RoleConfig) GetGoodwillRule() int32 {
	if x != nil {
		return x.GoodwillRule
	}
	return 0
}

func (x *RoleConfig) GetCanBeInvincible() bool {
	if x != nil {
		return x.CanBeInvincible
	}
	return false
}

// PlotConfig defines a story plot.
type PlotConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the plot.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The type of the plot.
	Type PlotType `protobuf:"varint,2,opt,name=type,proto3,enum=tragedylooper.v1.PlotType" json:"type,omitempty"`
	// The name of the plot.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// A description of the plot.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// A map of incident identifiers for this plot.
	IncidentIds map[int32]*IncidentConfig `protobuf:"bytes,5,rep,name=incident_ids,json=incidentIds,proto3" json:"incident_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of role assignments for this plot.
	RoleAssignments map[int32]int32 `protobuf:"bytes,6,rep,name=role_assignments,json=roleAssignments,proto3" json:"role_assignments,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PlotConfig) Reset() {
	*x = PlotConfig{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlotConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlotConfig) ProtoMessage() {}

func (x *PlotConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlotConfig.ProtoReflect.Descriptor instead.
func (*PlotConfig) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{5}
}

func (x *PlotConfig) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *PlotConfig) GetType() PlotType {
	if x != nil {
		return x.Type
	}
	return PlotType_PLOT_TYPE_UNSPECIFIED
}

func (x *PlotConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PlotConfig) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *PlotConfig) GetIncidentIds() map[int32]*IncidentConfig {
	if x != nil {
		return x.IncidentIds
	}
	return nil
}

func (x *PlotConfig) GetRoleAssignments() map[int32]int32 {
	if x != nil {
		return x.RoleAssignments
	}
	return nil
}

// ScriptConfigLib is a library of script configurations.
type ScriptConfigLib struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A map of script configurations.
	Scripts       map[int32]*ScriptConfig `protobuf:"bytes,1,rep,name=scripts,proto3" json:"scripts,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptConfigLib) Reset() {
	*x = ScriptConfigLib{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptConfigLib) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptConfigLib) ProtoMessage() {}

func (x *ScriptConfigLib) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptConfigLib.ProtoReflect.Descriptor instead.
func (*ScriptConfigLib) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{6}
}

func (x *ScriptConfigLib) GetScripts() map[int32]*ScriptConfig {
	if x != nil {
		return x.Scripts
	}
	return nil
}

var File_tragedylooper_v1_script_proto protoreflect.FileDescriptor

const file_tragedylooper_v1_script_proto_rawDesc = "" +
	"\n" +
	"\x1dtragedylooper/v1/script.proto\x12\x10tragedylooper.v1\x1a\x14vendor/cue/cue.proto\x1a\x1ctragedylooper/v1/enums.proto\x1a\x1ftragedylooper/v1/incident.proto\x1a tragedylooper/v1/character.proto\x1a\x1btragedylooper/v1/card.proto\x1a\x1etragedylooper/v1/ability.proto\"\xbe\x0f\n" +
	"\fScriptConfig\x12\x18\n" +
	"\x02id\x18\x01 \x01(\x05B\b\x82\xa4<\x04{>0}R\x02id\x12!\n" +
	"\x04name\x18\x02 \x01(\tB\r\x82\xa4<\t{len > 0}R\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x84\x01\n" +
	"\n" +
	"main_plots\x18\x04 \x03(\v2-.tragedylooper.v1.ScriptConfig.MainPlotsEntryB6\x82\xa4<2{ for k, v in main_plots { k: >= 1000 & < 2000 } }R\tmainPlots\x12\x80\x01\n" +
	"\tsub_plots\x18\x05 \x03(\v2,.tragedylooper.v1.ScriptConfig.SubPlotsEntryB5\x82\xa4<1{ for k, v in sub_plots { k: >= 2000 & < 3000 } }R\bsubPlots\x12r\n" +
	"\x05roles\x18\x06 \x03(\v2).tragedylooper.v1.ScriptConfig.RolesEntryB1\x82\xa4<-{ for k, v in roles { k: >= 3000 & < 4000 } }R\x05roles\x12\x82\x01\n" +
	"\tincidents\x18\a \x03(\v2-.tragedylooper.v1.ScriptConfig.IncidentsEntryB5\x82\xa4<1{ for k, v in incidents { k: >= 4000 & < 5000 } }R\tincidents\x12\x86\x01\n" +
	"\n" +
	"characters\x18\b \x03(\v2..tragedylooper.v1.ScriptConfig.CharactersEntryB6\x82\xa4<2{ for k, v in characters { k: >= 5000 & < 6000 } }R\n" +
	"characters\x12\x9c\x01\n" +
	"\x10mastermind_cards\x18\t \x03(\v23.tragedylooper.v1.ScriptConfig.MastermindCardsEntryB<\x82\xa4<8{ for k, v in mastermind_cards { k: >= 6000 & < 7000 } }R\x0fmastermindCards\x12\xa0\x01\n" +
	"\x11protagonist_cards\x18\n" +
	" \x03(\v24.tragedylooper.v1.ScriptConfig.ProtagonistCardsEntryB=\x82\xa4<9{ for k, v in protagonist_cards { k: >= 7000 & < 8000 } }R\x10protagonistCards\x12\x8a\x01\n" +
	"\rscript_models\x18\v \x03(\v20.tragedylooper.v1.ScriptConfig.ScriptModelsEntryB3\x82\xa4</{ for k, v in scripts { k: >= 8000 & < 9000 } }R\fscriptModels\x1aZ\n" +
	"\x0eMainPlotsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x122\n" +
	"\x05value\x18\x02 \x01(\v2\x1c.tragedylooper.v1.PlotConfigR\x05value:\x028\x01\x1aY\n" +
	"\rSubPlotsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x122\n" +
	"\x05value\x18\x02 \x01(\v2\x1c.tragedylooper.v1.PlotConfigR\x05value:\x028\x01\x1aV\n" +
	"\n" +
	"RolesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x122\n" +
	"\x05value\x18\x02 \x01(\v2\x1c.tragedylooper.v1.RoleConfigR\x05value:\x028\x01\x1a^\n" +
	"\x0eIncidentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\x1a`\n" +
	"\x0fCharactersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x127\n" +
	"\x05value\x18\x02 \x01(\v2!.tragedylooper.v1.CharacterConfigR\x05value:\x028\x01\x1a`\n" +
	"\x14MastermindCardsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x122\n" +
	"\x05value\x18\x02 \x01(\v2\x1c.tragedylooper.v1.CardConfigR\x05value:\x028\x01\x1aa\n" +
	"\x15ProtagonistCardsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x122\n" +
	"\x05value\x18\x02 \x01(\v2\x1c.tragedylooper.v1.CardConfigR\x05value:\x028\x01\x1a^\n" +
	"\x11ScriptModelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x123\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.tragedylooper.v1.ScriptModelR\x05value:\x028\x01\"\x8e\x01\n" +
	"\vScriptModel\x12@\n" +
	"\fprivate_info\x18\x01 \x01(\v2\x1d.tragedylooper.v1.PrivateInfoR\vprivateInfo\x12=\n" +
	"\vpublic_info\x18\x02 \x01(\v2\x1c.tragedylooper.v1.PublicInfoR\n" +
	"publicInfo\"\xe0\x03\n" +
	"\vPrivateInfo\x129\n" +
	"\tmain_plot\x18\x01 \x01(\v2\x1c.tragedylooper.v1.PlotConfigR\bmainPlot\x129\n" +
	"\tsub_plots\x18\x02 \x03(\v2\x1c.tragedylooper.v1.PlotConfigR\bsubPlots\x12M\n" +
	"\n" +
	"characters\x18\x03 \x03(\v2-.tragedylooper.v1.PrivateInfo.CharactersEntryR\n" +
	"characters\x12J\n" +
	"\tincidents\x18\x04 \x03(\v2,.tragedylooper.v1.PrivateInfo.IncidentsEntryR\tincidents\x1a`\n" +
	"\x0fCharactersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x127\n" +
	"\x05value\x18\x02 \x01(\v2!.tragedylooper.v1.CharacterConfigR\x05value:\x028\x01\x1a^\n" +
	"\x0eIncidentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\"\xd0\x04\n" +
	"\n" +
	"PublicInfo\x122\n" +
	"\x10script_config_id\x18\x01 \x01(\x05B\b\x82\xa4<\x04{>0}R\x0escriptConfigId\x12'\n" +
	"\n" +
	"loop_count\x18\x02 \x01(\x05B\b\x82\xa4<\x04{>0}R\tloopCount\x12,\n" +
	"\rdays_per_loop\x18\x03 \x01(\x05B\b\x82\xa4<\x04{>0}R\vdaysPerLoop\x12\x1f\n" +
	"\vcan_discuss\x18\x04 \x01(\bR\n" +
	"canDiscuss\x12_\n" +
	"\x11special_incidents\x18\x05 \x03(\v22.tragedylooper.v1.PublicInfo.SpecialIncidentsEntryR\x10specialIncidents\x12e\n" +
	"\x13scheduled_incidents\x18\x06 \x03(\v24.tragedylooper.v1.PublicInfo.ScheduledIncidentsEntryR\x12scheduledIncidents\x1ae\n" +
	"\x15SpecialIncidentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\x1ag\n" +
	"\x17ScheduledIncidentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\"\xf6\x02\n" +
	"\n" +
	"RoleConfig\x12\x18\n" +
	"\x02id\x18\x01 \x01(\x05B\b\x82\xa4<\x04{>0}R\x02id\x12!\n" +
	"\x04name\x18\x02 \x01(\tB\r\x82\xa4<\t{len > 0}R\x04name\x12\x1f\n" +
	"\x05limit\x18\x03 \x01(\x05B\t\x82\xa4<\x05{>=1}R\x05limit\x12I\n" +
	"\tabilities\x18\x04 \x03(\v2+.tragedylooper.v1.RoleConfig.AbilitiesEntryR\tabilities\x124\n" +
	"\rgoodwill_rule\x18\x05 \x01(\x05B\x0f\x82\xa4<\v{>=0 & <=2}R\fgoodwillRule\x12*\n" +
	"\x11can_be_invincible\x18\x06 \x01(\bR\x0fcanBeInvincible\x1a]\n" +
	"\x0eAbilitiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.tragedylooper.v1.AbilityConfigR\x05value:\x028\x01\"\xf1\x03\n" +
	"\n" +
	"PlotConfig\x12\x18\n" +
	"\x02id\x18\x01 \x01(\x05B\b\x82\xa4<\x04{>0}R\x02id\x12.\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1a.tragedylooper.v1.PlotTypeR\x04type\x12!\n" +
	"\x04name\x18\x03 \x01(\tB\r\x82\xa4<\t{len > 0}R\x04name\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12P\n" +
	"\fincident_ids\x18\x05 \x03(\v2-.tragedylooper.v1.PlotConfig.IncidentIdsEntryR\vincidentIds\x12\\\n" +
	"\x10role_assignments\x18\x06 \x03(\v21.tragedylooper.v1.PlotConfig.RoleAssignmentsEntryR\x0froleAssignments\x1a`\n" +
	"\x10IncidentIdsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\x1aB\n" +
	"\x14RoleAssignmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xb7\x01\n" +
	"\x0fScriptConfigLib\x12H\n" +
	"\ascripts\x18\x01 \x03(\v2..tragedylooper.v1.ScriptConfigLib.ScriptsEntryR\ascripts\x1aZ\n" +
	"\fScriptsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x124\n" +
	"\x05value\x18\x02 \x01(\v2\x1e.tragedylooper.v1.ScriptConfigR\x05value:\x028\x01B7Z5github.com/constellation39/tragedyLooper/pkg/proto/v1b\x06proto3"

var (
	file_tragedylooper_v1_script_proto_rawDescOnce sync.Once
	file_tragedylooper_v1_script_proto_rawDescData []byte
)

func file_tragedylooper_v1_script_proto_rawDescGZIP() []byte {
	file_tragedylooper_v1_script_proto_rawDescOnce.Do(func() {
		file_tragedylooper_v1_script_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tragedylooper_v1_script_proto_rawDesc), len(file_tragedylooper_v1_script_proto_rawDesc)))
	})
	return file_tragedylooper_v1_script_proto_rawDescData
}

var file_tragedylooper_v1_script_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_tragedylooper_v1_script_proto_goTypes = []any{
	(*ScriptConfig)(nil),    // 0: tragedylooper.v1.ScriptConfig
	(*ScriptModel)(nil),     // 1: tragedylooper.v1.ScriptModel
	(*PrivateInfo)(nil),     // 2: tragedylooper.v1.PrivateInfo
	(*PublicInfo)(nil),      // 3: tragedylooper.v1.PublicInfo
	(*RoleConfig)(nil),      // 4: tragedylooper.v1.RoleConfig
	(*PlotConfig)(nil),      // 5: tragedylooper.v1.PlotConfig
	(*ScriptConfigLib)(nil), // 6: tragedylooper.v1.ScriptConfigLib
	nil,                     // 7: tragedylooper.v1.ScriptConfig.MainPlotsEntry
	nil,                     // 8: tragedylooper.v1.ScriptConfig.SubPlotsEntry
	nil,                     // 9: tragedylooper.v1.ScriptConfig.RolesEntry
	nil,                     // 10: tragedylooper.v1.ScriptConfig.IncidentsEntry
	nil,                     // 11: tragedylooper.v1.ScriptConfig.CharactersEntry
	nil,                     // 12: tragedylooper.v1.ScriptConfig.MastermindCardsEntry
	nil,                     // 13: tragedylooper.v1.ScriptConfig.ProtagonistCardsEntry
	nil,                     // 14: tragedylooper.v1.ScriptConfig.ScriptModelsEntry
	nil,                     // 15: tragedylooper.v1.PrivateInfo.CharactersEntry
	nil,                     // 16: tragedylooper.v1.PrivateInfo.IncidentsEntry
	nil,                     // 17: tragedylooper.v1.PublicInfo.SpecialIncidentsEntry
	nil,                     // 18: tragedylooper.v1.PublicInfo.ScheduledIncidentsEntry
	nil,                     // 19: tragedylooper.v1.RoleConfig.AbilitiesEntry
	nil,                     // 20: tragedylooper.v1.PlotConfig.IncidentIdsEntry
	nil,                     // 21: tragedylooper.v1.PlotConfig.RoleAssignmentsEntry
	nil,                     // 22: tragedylooper.v1.ScriptConfigLib.ScriptsEntry
	(PlotType)(0),           // 23: tragedylooper.v1.PlotType
	(*IncidentConfig)(nil),  // 24: tragedylooper.v1.IncidentConfig
	(*CharacterConfig)(nil), // 25: tragedylooper.v1.CharacterConfig
	(*CardConfig)(nil),      // 26: tragedylooper.v1.CardConfig
	(*AbilityConfig)(nil),   // 27: tragedylooper.v1.AbilityConfig
}
var file_tragedylooper_v1_script_proto_depIdxs = []int32{
	7,  // 0: tragedylooper.v1.ScriptConfig.main_plots:type_name -> tragedylooper.v1.ScriptConfig.MainPlotsEntry
	8,  // 1: tragedylooper.v1.ScriptConfig.sub_plots:type_name -> tragedylooper.v1.ScriptConfig.SubPlotsEntry
	9,  // 2: tragedylooper.v1.ScriptConfig.roles:type_name -> tragedylooper.v1.ScriptConfig.RolesEntry
	10, // 3: tragedylooper.v1.ScriptConfig.incidents:type_name -> tragedylooper.v1.ScriptConfig.IncidentsEntry
	11, // 4: tragedylooper.v1.ScriptConfig.characters:type_name -> tragedylooper.v1.ScriptConfig.CharactersEntry
	12, // 5: tragedylooper.v1.ScriptConfig.mastermind_cards:type_name -> tragedylooper.v1.ScriptConfig.MastermindCardsEntry
	13, // 6: tragedylooper.v1.ScriptConfig.protagonist_cards:type_name -> tragedylooper.v1.ScriptConfig.ProtagonistCardsEntry
	14, // 7: tragedylooper.v1.ScriptConfig.script_models:type_name -> tragedylooper.v1.ScriptConfig.ScriptModelsEntry
	2,  // 8: tragedylooper.v1.ScriptModel.private_info:type_name -> tragedylooper.v1.PrivateInfo
	3,  // 9: tragedylooper.v1.ScriptModel.public_info:type_name -> tragedylooper.v1.PublicInfo
	5,  // 10: tragedylooper.v1.PrivateInfo.main_plot:type_name -> tragedylooper.v1.PlotConfig
	5,  // 11: tragedylooper.v1.PrivateInfo.sub_plots:type_name -> tragedylooper.v1.PlotConfig
	15, // 12: tragedylooper.v1.PrivateInfo.characters:type_name -> tragedylooper.v1.PrivateInfo.CharactersEntry
	16, // 13: tragedylooper.v1.PrivateInfo.incidents:type_name -> tragedylooper.v1.PrivateInfo.IncidentsEntry
	17, // 14: tragedylooper.v1.PublicInfo.special_incidents:type_name -> tragedylooper.v1.PublicInfo.SpecialIncidentsEntry
	18, // 15: tragedylooper.v1.PublicInfo.scheduled_incidents:type_name -> tragedylooper.v1.PublicInfo.ScheduledIncidentsEntry
	19, // 16: tragedylooper.v1.RoleConfig.abilities:type_name -> tragedylooper.v1.RoleConfig.AbilitiesEntry
	23, // 17: tragedylooper.v1.PlotConfig.type:type_name -> tragedylooper.v1.PlotType
	20, // 18: tragedylooper.v1.PlotConfig.incident_ids:type_name -> tragedylooper.v1.PlotConfig.IncidentIdsEntry
	21, // 19: tragedylooper.v1.PlotConfig.role_assignments:type_name -> tragedylooper.v1.PlotConfig.RoleAssignmentsEntry
	22, // 20: tragedylooper.v1.ScriptConfigLib.scripts:type_name -> tragedylooper.v1.ScriptConfigLib.ScriptsEntry
	5,  // 21: tragedylooper.v1.ScriptConfig.MainPlotsEntry.value:type_name -> tragedylooper.v1.PlotConfig
	5,  // 22: tragedylooper.v1.ScriptConfig.SubPlotsEntry.value:type_name -> tragedylooper.v1.PlotConfig
	4,  // 23: tragedylooper.v1.ScriptConfig.RolesEntry.value:type_name -> tragedylooper.v1.RoleConfig
	24, // 24: tragedylooper.v1.ScriptConfig.IncidentsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	25, // 25: tragedylooper.v1.ScriptConfig.CharactersEntry.value:type_name -> tragedylooper.v1.CharacterConfig
	26, // 26: tragedylooper.v1.ScriptConfig.MastermindCardsEntry.value:type_name -> tragedylooper.v1.CardConfig
	26, // 27: tragedylooper.v1.ScriptConfig.ProtagonistCardsEntry.value:type_name -> tragedylooper.v1.CardConfig
	1,  // 28: tragedylooper.v1.ScriptConfig.ScriptModelsEntry.value:type_name -> tragedylooper.v1.ScriptModel
	25, // 29: tragedylooper.v1.PrivateInfo.CharactersEntry.value:type_name -> tragedylooper.v1.CharacterConfig
	24, // 30: tragedylooper.v1.PrivateInfo.IncidentsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	24, // 31: tragedylooper.v1.PublicInfo.SpecialIncidentsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	24, // 32: tragedylooper.v1.PublicInfo.ScheduledIncidentsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	27, // 33: tragedylooper.v1.RoleConfig.AbilitiesEntry.value:type_name -> tragedylooper.v1.AbilityConfig
	24, // 34: tragedylooper.v1.PlotConfig.IncidentIdsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	0,  // 35: tragedylooper.v1.ScriptConfigLib.ScriptsEntry.value:type_name -> tragedylooper.v1.ScriptConfig
	36, // [36:36] is the sub-list for method output_type
	36, // [36:36] is the sub-list for method input_type
	36, // [36:36] is the sub-list for extension type_name
	36, // [36:36] is the sub-list for extension extendee
	0,  // [0:36] is the sub-list for field type_name
}

func init() { file_tragedylooper_v1_script_proto_init() }
func file_tragedylooper_v1_script_proto_init() {
	if File_tragedylooper_v1_script_proto != nil {
		return
	}
	file_tragedylooper_v1_enums_proto_init()
	file_tragedylooper_v1_incident_proto_init()
	file_tragedylooper_v1_character_proto_init()
	file_tragedylooper_v1_card_proto_init()
	file_tragedylooper_v1_ability_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tragedylooper_v1_script_proto_rawDesc), len(file_tragedylooper_v1_script_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   23,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tragedylooper_v1_script_proto_goTypes,
		DependencyIndexes: file_tragedylooper_v1_script_proto_depIdxs,
		MessageInfos:      file_tragedylooper_v1_script_proto_msgTypes,
	}.Build()
	File_tragedylooper_v1_script_proto = out.File
	file_tragedylooper_v1_script_proto_goTypes = nil
	file_tragedylooper_v1_script_proto_depIdxs = nil
}
