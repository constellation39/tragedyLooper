// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: tragedylooper/v1/script.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Script defines the configuration for a tragedy looper script.
type ScriptConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the script.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the script.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// A description of the script.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// A map of all script entities, keyed by a unique ID.
	Entities      map[int32]*ScriptEntity `protobuf:"bytes,4,rep,name=entities,proto3" json:"entities,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptConfig) Reset() {
	*x = ScriptConfig{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptConfig) ProtoMessage() {}

func (x *ScriptConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptConfig.ProtoReflect.Descriptor instead.
func (*ScriptConfig) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{0}
}

func (x *ScriptConfig) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *ScriptConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ScriptConfig) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ScriptConfig) GetEntities() map[int32]*ScriptEntity {
	if x != nil {
		return x.Entities
	}
	return nil
}

// ScriptEntity wraps all possible configuration objects that can be part of a script.
// This ensures that each entity has a unique ID within the script.
type ScriptEntity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Entity:
	//
	//	*ScriptEntity_MainPlot
	//	*ScriptEntity_SubPlot
	//	*ScriptEntity_Role
	//	*ScriptEntity_Incident
	//	*ScriptEntity_Character
	//	*ScriptEntity_MastermindCard
	//	*ScriptEntity_ProtagonistCard
	//	*ScriptEntity_ScriptModel
	Entity        isScriptEntity_Entity `protobuf_oneof:"entity"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptEntity) Reset() {
	*x = ScriptEntity{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptEntity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptEntity) ProtoMessage() {}

func (x *ScriptEntity) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptEntity.ProtoReflect.Descriptor instead.
func (*ScriptEntity) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{1}
}

func (x *ScriptEntity) GetEntity() isScriptEntity_Entity {
	if x != nil {
		return x.Entity
	}
	return nil
}

func (x *ScriptEntity) GetMainPlot() *PlotConfig {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_MainPlot); ok {
			return x.MainPlot
		}
	}
	return nil
}

func (x *ScriptEntity) GetSubPlot() *PlotConfig {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_SubPlot); ok {
			return x.SubPlot
		}
	}
	return nil
}

func (x *ScriptEntity) GetRole() *RoleConfig {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_Role); ok {
			return x.Role
		}
	}
	return nil
}

func (x *ScriptEntity) GetIncident() *IncidentConfig {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_Incident); ok {
			return x.Incident
		}
	}
	return nil
}

func (x *ScriptEntity) GetCharacter() *CharacterConfig {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_Character); ok {
			return x.Character
		}
	}
	return nil
}

func (x *ScriptEntity) GetMastermindCard() *CardConfig {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_MastermindCard); ok {
			return x.MastermindCard
		}
	}
	return nil
}

func (x *ScriptEntity) GetProtagonistCard() *CardConfig {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_ProtagonistCard); ok {
			return x.ProtagonistCard
		}
	}
	return nil
}

func (x *ScriptEntity) GetScriptModel() *ScriptModel {
	if x != nil {
		if x, ok := x.Entity.(*ScriptEntity_ScriptModel); ok {
			return x.ScriptModel
		}
	}
	return nil
}

type isScriptEntity_Entity interface {
	isScriptEntity_Entity()
}

type ScriptEntity_MainPlot struct {
	MainPlot *PlotConfig `protobuf:"bytes,1,opt,name=main_plot,json=mainPlot,proto3,oneof"`
}

type ScriptEntity_SubPlot struct {
	SubPlot *PlotConfig `protobuf:"bytes,2,opt,name=sub_plot,json=subPlot,proto3,oneof"`
}

type ScriptEntity_Role struct {
	Role *RoleConfig `protobuf:"bytes,3,opt,name=role,proto3,oneof"`
}

type ScriptEntity_Incident struct {
	Incident *IncidentConfig `protobuf:"bytes,4,opt,name=incident,proto3,oneof"`
}

type ScriptEntity_Character struct {
	Character *CharacterConfig `protobuf:"bytes,5,opt,name=character,proto3,oneof"`
}

type ScriptEntity_MastermindCard struct {
	MastermindCard *CardConfig `protobuf:"bytes,6,opt,name=mastermind_card,json=mastermindCard,proto3,oneof"`
}

type ScriptEntity_ProtagonistCard struct {
	ProtagonistCard *CardConfig `protobuf:"bytes,7,opt,name=protagonist_card,json=protagonistCard,proto3,oneof"`
}

type ScriptEntity_ScriptModel struct {
	ScriptModel *ScriptModel `protobuf:"bytes,8,opt,name=script_model,json=scriptModel,proto3,oneof"`
}

func (*ScriptEntity_MainPlot) isScriptEntity_Entity() {}

func (*ScriptEntity_SubPlot) isScriptEntity_Entity() {}

func (*ScriptEntity_Role) isScriptEntity_Entity() {}

func (*ScriptEntity_Incident) isScriptEntity_Entity() {}

func (*ScriptEntity_Character) isScriptEntity_Entity() {}

func (*ScriptEntity_MastermindCard) isScriptEntity_Entity() {}

func (*ScriptEntity_ProtagonistCard) isScriptEntity_Entity() {}

func (*ScriptEntity_ScriptModel) isScriptEntity_Entity() {}

// ScriptConfig defines the configuration for a specific script.
type ScriptModel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Private information for the script.
	PrivateInfo *PrivateInfo `protobuf:"bytes,1,opt,name=private_info,json=privateInfo,proto3" json:"private_info,omitempty"`
	// Public information for the script.
	PublicInfo    *PublicInfo `protobuf:"bytes,2,opt,name=public_info,json=publicInfo,proto3" json:"public_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptModel) Reset() {
	*x = ScriptModel{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptModel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptModel) ProtoMessage() {}

func (x *ScriptModel) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptModel.ProtoReflect.Descriptor instead.
func (*ScriptModel) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{2}
}

func (x *ScriptModel) GetPrivateInfo() *PrivateInfo {
	if x != nil {
		return x.PrivateInfo
	}
	return nil
}

func (x *ScriptModel) GetPublicInfo() *PublicInfo {
	if x != nil {
		return x.PublicInfo
	}
	return nil
}

// PrivateInfo defines the private information for a script.
type PrivateInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The main plot of the script.
	MainPlot *PlotConfig `protobuf:"bytes,1,opt,name=main_plot,json=mainPlot,proto3" json:"main_plot,omitempty"`
	// A list of sub plots for the script.
	SubPlots []*PlotConfig `protobuf:"bytes,2,rep,name=sub_plots,json=subPlots,proto3" json:"sub_plots,omitempty"`
	// A map of characters in the script.
	Characters map[int32]*CharacterConfig `protobuf:"bytes,3,rep,name=characters,proto3" json:"characters,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of incidents in the script.
	Incidents     map[int32]*IncidentConfig `protobuf:"bytes,4,rep,name=incidents,proto3" json:"incidents,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrivateInfo) Reset() {
	*x = PrivateInfo{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrivateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrivateInfo) ProtoMessage() {}

func (x *PrivateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrivateInfo.ProtoReflect.Descriptor instead.
func (*PrivateInfo) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{3}
}

func (x *PrivateInfo) GetMainPlot() *PlotConfig {
	if x != nil {
		return x.MainPlot
	}
	return nil
}

func (x *PrivateInfo) GetSubPlots() []*PlotConfig {
	if x != nil {
		return x.SubPlots
	}
	return nil
}

func (x *PrivateInfo) GetCharacters() map[int32]*CharacterConfig {
	if x != nil {
		return x.Characters
	}
	return nil
}

func (x *PrivateInfo) GetIncidents() map[int32]*IncidentConfig {
	if x != nil {
		return x.Incidents
	}
	return nil
}

// PublicInfo defines the public information for a script.
type PublicInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the script configuration.
	ScriptConfigId int32 `protobuf:"varint,1,opt,name=script_config_id,json=scriptConfigId,proto3" json:"script_config_id,omitempty"`
	// Game rules.
	// The number of loops in the game.
	LoopCount int32 `protobuf:"varint,2,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	// The number of days per loop.
	DaysPerLoop int32 `protobuf:"varint,3,opt,name=days_per_loop,json=daysPerLoop,proto3" json:"days_per_loop,omitempty"`
	// Whether players can discuss information.
	CanDiscuss bool `protobuf:"varint,4,opt,name=can_discuss,json=canDiscuss,proto3" json:"can_discuss,omitempty"`
	// Special rules.
	// A map of special incidents.
	SpecialIncidents map[int32]*IncidentConfig `protobuf:"bytes,5,rep,name=special_incidents,json=specialIncidents,proto3" json:"special_incidents,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of scheduled incidents.
	ScheduledIncidents map[int32]*IncidentConfig `protobuf:"bytes,6,rep,name=scheduled_incidents,json=scheduledIncidents,proto3" json:"scheduled_incidents,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PublicInfo) Reset() {
	*x = PublicInfo{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicInfo) ProtoMessage() {}

func (x *PublicInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicInfo.ProtoReflect.Descriptor instead.
func (*PublicInfo) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{4}
}

func (x *PublicInfo) GetScriptConfigId() int32 {
	if x != nil {
		return x.ScriptConfigId
	}
	return 0
}

func (x *PublicInfo) GetLoopCount() int32 {
	if x != nil {
		return x.LoopCount
	}
	return 0
}

func (x *PublicInfo) GetDaysPerLoop() int32 {
	if x != nil {
		return x.DaysPerLoop
	}
	return 0
}

func (x *PublicInfo) GetCanDiscuss() bool {
	if x != nil {
		return x.CanDiscuss
	}
	return false
}

func (x *PublicInfo) GetSpecialIncidents() map[int32]*IncidentConfig {
	if x != nil {
		return x.SpecialIncidents
	}
	return nil
}

func (x *PublicInfo) GetScheduledIncidents() map[int32]*IncidentConfig {
	if x != nil {
		return x.ScheduledIncidents
	}
	return nil
}

// RoleConfig defines the configuration for a role.
type RoleConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the role.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the role.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The limit of characters that can have this role.
	Limit int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// A map of abilities for this role.
	Abilities map[int32]*AbilityConfig `protobuf:"bytes,4,rep,name=abilities,proto3" json:"abilities,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Defines the character's goodwill status.
	// 0: normal, 1: ignore goodwill, 2: always ignore goodwill.
	GoodwillRule int32 `protobuf:"varint,5,opt,name=goodwill_rule,json=goodwillRule,proto3" json:"goodwill_rule,omitempty"`
	// Defines if the character can be made invincible.
	CanBeInvincible bool `protobuf:"varint,6,opt,name=can_be_invincible,json=canBeInvincible,proto3" json:"can_be_invincible,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RoleConfig) Reset() {
	*x = RoleConfig{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoleConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoleConfig) ProtoMessage() {}

func (x *RoleConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoleConfig.ProtoReflect.Descriptor instead.
func (*RoleConfig) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{5}
}

func (x *RoleConfig) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *RoleConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RoleConfig) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *RoleConfig) GetAbilities() map[int32]*AbilityConfig {
	if x != nil {
		return x.Abilities
	}
	return nil
}

func (x *RoleConfig) GetGoodwillRule() int32 {
	if x != nil {
		return x.GoodwillRule
	}
	return 0
}

func (x *RoleConfig) GetCanBeInvincible() bool {
	if x != nil {
		return x.CanBeInvincible
	}
	return false
}

// PlotConfig defines a story plot.
type PlotConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier for the plot.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The type of the plot.
	Type PlotType `protobuf:"varint,2,opt,name=type,proto3,enum=tragedylooper.v1.PlotType" json:"type,omitempty"`
	// The name of the plot.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// A description of the plot.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// A map of incident identifiers for this plot.
	IncidentIds map[int32]*IncidentConfig `protobuf:"bytes,5,rep,name=incident_ids,json=incidentIds,proto3" json:"incident_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A map of role assignments for this plot.
	RoleAssignments map[int32]int32 `protobuf:"bytes,6,rep,name=role_assignments,json=roleAssignments,proto3" json:"role_assignments,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PlotConfig) Reset() {
	*x = PlotConfig{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlotConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlotConfig) ProtoMessage() {}

func (x *PlotConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlotConfig.ProtoReflect.Descriptor instead.
func (*PlotConfig) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{6}
}

func (x *PlotConfig) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *PlotConfig) GetType() PlotType {
	if x != nil {
		return x.Type
	}
	return PlotType_PLOT_TYPE_UNSPECIFIED
}

func (x *PlotConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PlotConfig) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *PlotConfig) GetIncidentIds() map[int32]*IncidentConfig {
	if x != nil {
		return x.IncidentIds
	}
	return nil
}

func (x *PlotConfig) GetRoleAssignments() map[int32]int32 {
	if x != nil {
		return x.RoleAssignments
	}
	return nil
}

// ScriptConfigLib is a library of script configurations.
type ScriptConfigLib struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A map of script configurations.
	Scripts       map[int32]*ScriptConfig `protobuf:"bytes,1,rep,name=scripts,proto3" json:"scripts,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptConfigLib) Reset() {
	*x = ScriptConfigLib{}
	mi := &file_tragedylooper_v1_script_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptConfigLib) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptConfigLib) ProtoMessage() {}

func (x *ScriptConfigLib) ProtoReflect() protoreflect.Message {
	mi := &file_tragedylooper_v1_script_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptConfigLib.ProtoReflect.Descriptor instead.
func (*ScriptConfigLib) Descriptor() ([]byte, []int) {
	return file_tragedylooper_v1_script_proto_rawDescGZIP(), []int{7}
}

func (x *ScriptConfigLib) GetScripts() map[int32]*ScriptConfig {
	if x != nil {
		return x.Scripts
	}
	return nil
}

var File_tragedylooper_v1_script_proto protoreflect.FileDescriptor

const file_tragedylooper_v1_script_proto_rawDesc = "" +
	"\n" +
	"\x1dtragedylooper/v1/script.proto\x12\x10tragedylooper.v1\x1a tragedylooper/v1/condition.proto\x1a\x1dtragedylooper/v1/effect.proto\x1a\x1ctragedylooper/v1/enums.proto\x1a\x1ftragedylooper/v1/incident.proto\x1a tragedylooper/v1/character.proto\x1a\x1btragedylooper/v1/card.proto\x1a\x1etragedylooper/v1/ability.proto\"\xfb\x01\n" +
	"\fScriptConfig\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x05R\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12H\n" +
	"\bentities\x18\x04 \x03(\v2,.tragedylooper.v1.ScriptConfig.EntitiesEntryR\bentities\x1a[\n" +
	"\rEntitiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x124\n" +
	"\x05value\x18\x02 \x01(\v2\x1e.tragedylooper.v1.ScriptEntityR\x05value:\x028\x01\"\x9f\x04\n" +
	"\fScriptEntity\x12;\n" +
	"\tmain_plot\x18\x01 \x01(\v2\x1c.tragedylooper.v1.PlotConfigH\x00R\bmainPlot\x129\n" +
	"\bsub_plot\x18\x02 \x01(\v2\x1c.tragedylooper.v1.PlotConfigH\x00R\asubPlot\x122\n" +
	"\x04role\x18\x03 \x01(\v2\x1c.tragedylooper.v1.RoleConfigH\x00R\x04role\x12>\n" +
	"\bincident\x18\x04 \x01(\v2 .tragedylooper.v1.IncidentConfigH\x00R\bincident\x12A\n" +
	"\tcharacter\x18\x05 \x01(\v2!.tragedylooper.v1.CharacterConfigH\x00R\tcharacter\x12G\n" +
	"\x0fmastermind_card\x18\x06 \x01(\v2\x1c.tragedylooper.v1.CardConfigH\x00R\x0emastermindCard\x12I\n" +
	"\x10protagonist_card\x18\a \x01(\v2\x1c.tragedylooper.v1.CardConfigH\x00R\x0fprotagonistCard\x12B\n" +
	"\fscript_model\x18\b \x01(\v2\x1d.tragedylooper.v1.ScriptModelH\x00R\vscriptModelB\b\n" +
	"\x06entity\"\x8e\x01\n" +
	"\vScriptModel\x12@\n" +
	"\fprivate_info\x18\x01 \x01(\v2\x1d.tragedylooper.v1.PrivateInfoR\vprivateInfo\x12=\n" +
	"\vpublic_info\x18\x02 \x01(\v2\x1c.tragedylooper.v1.PublicInfoR\n" +
	"publicInfo\"\xe0\x03\n" +
	"\vPrivateInfo\x129\n" +
	"\tmain_plot\x18\x01 \x01(\v2\x1c.tragedylooper.v1.PlotConfigR\bmainPlot\x129\n" +
	"\tsub_plots\x18\x02 \x03(\v2\x1c.tragedylooper.v1.PlotConfigR\bsubPlots\x12M\n" +
	"\n" +
	"characters\x18\x03 \x03(\v2-.tragedylooper.v1.PrivateInfo.CharactersEntryR\n" +
	"characters\x12J\n" +
	"\tincidents\x18\x04 \x03(\v2,.tragedylooper.v1.PrivateInfo.IncidentsEntryR\tincidents\x1a`\n" +
	"\x0fCharactersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x127\n" +
	"\x05value\x18\x02 \x01(\v2!.tragedylooper.v1.CharacterConfigR\x05value:\x028\x01\x1a^\n" +
	"\x0eIncidentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\"\xb2\x04\n" +
	"\n" +
	"PublicInfo\x12(\n" +
	"\x10script_config_id\x18\x01 \x01(\x05R\x0escriptConfigId\x12\x1d\n" +
	"\n" +
	"loop_count\x18\x02 \x01(\x05R\tloopCount\x12\"\n" +
	"\rdays_per_loop\x18\x03 \x01(\x05R\vdaysPerLoop\x12\x1f\n" +
	"\vcan_discuss\x18\x04 \x01(\bR\n" +
	"canDiscuss\x12_\n" +
	"\x11special_incidents\x18\x05 \x03(\v22.tragedylooper.v1.PublicInfo.SpecialIncidentsEntryR\x10specialIncidents\x12e\n" +
	"\x13scheduled_incidents\x18\x06 \x03(\v24.tragedylooper.v1.PublicInfo.ScheduledIncidentsEntryR\x12scheduledIncidents\x1ae\n" +
	"\x15SpecialIncidentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\x1ag\n" +
	"\x17ScheduledIncidentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\"\xc1\x02\n" +
	"\n" +
	"RoleConfig\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x05R\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05limit\x18\x03 \x01(\x05R\x05limit\x12I\n" +
	"\tabilities\x18\x04 \x03(\v2+.tragedylooper.v1.RoleConfig.AbilitiesEntryR\tabilities\x12#\n" +
	"\rgoodwill_rule\x18\x05 \x01(\x05R\fgoodwillRule\x12*\n" +
	"\x11can_be_invincible\x18\x06 \x01(\bR\x0fcanBeInvincible\x1a]\n" +
	"\x0eAbilitiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.tragedylooper.v1.AbilityConfigR\x05value:\x028\x01\"\xd8\x03\n" +
	"\n" +
	"PlotConfig\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x05R\x02id\x12.\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1a.tragedylooper.v1.PlotTypeR\x04type\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12P\n" +
	"\fincident_ids\x18\x05 \x03(\v2-.tragedylooper.v1.PlotConfig.IncidentIdsEntryR\vincidentIds\x12\\\n" +
	"\x10role_assignments\x18\x06 \x03(\v21.tragedylooper.v1.PlotConfig.RoleAssignmentsEntryR\x0froleAssignments\x1a`\n" +
	"\x10IncidentIdsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .tragedylooper.v1.IncidentConfigR\x05value:\x028\x01\x1aB\n" +
	"\x14RoleAssignmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xb7\x01\n" +
	"\x0fScriptConfigLib\x12H\n" +
	"\ascripts\x18\x01 \x03(\v2..tragedylooper.v1.ScriptConfigLib.ScriptsEntryR\ascripts\x1aZ\n" +
	"\fScriptsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x124\n" +
	"\x05value\x18\x02 \x01(\v2\x1e.tragedylooper.v1.ScriptConfigR\x05value:\x028\x01B7Z5github.com/constellation39/tragedyLooper/pkg/proto/v1b\x06proto3"

var (
	file_tragedylooper_v1_script_proto_rawDescOnce sync.Once
	file_tragedylooper_v1_script_proto_rawDescData []byte
)

func file_tragedylooper_v1_script_proto_rawDescGZIP() []byte {
	file_tragedylooper_v1_script_proto_rawDescOnce.Do(func() {
		file_tragedylooper_v1_script_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tragedylooper_v1_script_proto_rawDesc), len(file_tragedylooper_v1_script_proto_rawDesc)))
	})
	return file_tragedylooper_v1_script_proto_rawDescData
}

var file_tragedylooper_v1_script_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_tragedylooper_v1_script_proto_goTypes = []any{
	(*ScriptConfig)(nil),    // 0: tragedylooper.v1.ScriptConfig
	(*ScriptEntity)(nil),    // 1: tragedylooper.v1.ScriptEntity
	(*ScriptModel)(nil),     // 2: tragedylooper.v1.ScriptModel
	(*PrivateInfo)(nil),     // 3: tragedylooper.v1.PrivateInfo
	(*PublicInfo)(nil),      // 4: tragedylooper.v1.PublicInfo
	(*RoleConfig)(nil),      // 5: tragedylooper.v1.RoleConfig
	(*PlotConfig)(nil),      // 6: tragedylooper.v1.PlotConfig
	(*ScriptConfigLib)(nil), // 7: tragedylooper.v1.ScriptConfigLib
	nil,                     // 8: tragedylooper.v1.ScriptConfig.EntitiesEntry
	nil,                     // 9: tragedylooper.v1.PrivateInfo.CharactersEntry
	nil,                     // 10: tragedylooper.v1.PrivateInfo.IncidentsEntry
	nil,                     // 11: tragedylooper.v1.PublicInfo.SpecialIncidentsEntry
	nil,                     // 12: tragedylooper.v1.PublicInfo.ScheduledIncidentsEntry
	nil,                     // 13: tragedylooper.v1.RoleConfig.AbilitiesEntry
	nil,                     // 14: tragedylooper.v1.PlotConfig.IncidentIdsEntry
	nil,                     // 15: tragedylooper.v1.PlotConfig.RoleAssignmentsEntry
	nil,                     // 16: tragedylooper.v1.ScriptConfigLib.ScriptsEntry
	(*IncidentConfig)(nil),  // 17: tragedylooper.v1.IncidentConfig
	(*CharacterConfig)(nil), // 18: tragedylooper.v1.CharacterConfig
	(*CardConfig)(nil),      // 19: tragedylooper.v1.CardConfig
	(PlotType)(0),           // 20: tragedylooper.v1.PlotType
	(*AbilityConfig)(nil),   // 21: tragedylooper.v1.AbilityConfig
}
var file_tragedylooper_v1_script_proto_depIdxs = []int32{
	8,  // 0: tragedylooper.v1.ScriptConfig.entities:type_name -> tragedylooper.v1.ScriptConfig.EntitiesEntry
	6,  // 1: tragedylooper.v1.ScriptEntity.main_plot:type_name -> tragedylooper.v1.PlotConfig
	6,  // 2: tragedylooper.v1.ScriptEntity.sub_plot:type_name -> tragedylooper.v1.PlotConfig
	5,  // 3: tragedylooper.v1.ScriptEntity.role:type_name -> tragedylooper.v1.RoleConfig
	17, // 4: tragedylooper.v1.ScriptEntity.incident:type_name -> tragedylooper.v1.IncidentConfig
	18, // 5: tragedylooper.v1.ScriptEntity.character:type_name -> tragedylooper.v1.CharacterConfig
	19, // 6: tragedylooper.v1.ScriptEntity.mastermind_card:type_name -> tragedylooper.v1.CardConfig
	19, // 7: tragedylooper.v1.ScriptEntity.protagonist_card:type_name -> tragedylooper.v1.CardConfig
	2,  // 8: tragedylooper.v1.ScriptEntity.script_model:type_name -> tragedylooper.v1.ScriptModel
	3,  // 9: tragedylooper.v1.ScriptModel.private_info:type_name -> tragedylooper.v1.PrivateInfo
	4,  // 10: tragedylooper.v1.ScriptModel.public_info:type_name -> tragedylooper.v1.PublicInfo
	6,  // 11: tragedylooper.v1.PrivateInfo.main_plot:type_name -> tragedylooper.v1.PlotConfig
	6,  // 12: tragedylooper.v1.PrivateInfo.sub_plots:type_name -> tragedylooper.v1.PlotConfig
	9,  // 13: tragedylooper.v1.PrivateInfo.characters:type_name -> tragedylooper.v1.PrivateInfo.CharactersEntry
	10, // 14: tragedylooper.v1.PrivateInfo.incidents:type_name -> tragedylooper.v1.PrivateInfo.IncidentsEntry
	11, // 15: tragedylooper.v1.PublicInfo.special_incidents:type_name -> tragedylooper.v1.PublicInfo.SpecialIncidentsEntry
	12, // 16: tragedylooper.v1.PublicInfo.scheduled_incidents:type_name -> tragedylooper.v1.PublicInfo.ScheduledIncidentsEntry
	13, // 17: tragedylooper.v1.RoleConfig.abilities:type_name -> tragedylooper.v1.RoleConfig.AbilitiesEntry
	20, // 18: tragedylooper.v1.PlotConfig.type:type_name -> tragedylooper.v1.PlotType
	14, // 19: tragedylooper.v1.PlotConfig.incident_ids:type_name -> tragedylooper.v1.PlotConfig.IncidentIdsEntry
	15, // 20: tragedylooper.v1.PlotConfig.role_assignments:type_name -> tragedylooper.v1.PlotConfig.RoleAssignmentsEntry
	16, // 21: tragedylooper.v1.ScriptConfigLib.scripts:type_name -> tragedylooper.v1.ScriptConfigLib.ScriptsEntry
	1,  // 22: tragedylooper.v1.ScriptConfig.EntitiesEntry.value:type_name -> tragedylooper.v1.ScriptEntity
	18, // 23: tragedylooper.v1.PrivateInfo.CharactersEntry.value:type_name -> tragedylooper.v1.CharacterConfig
	17, // 24: tragedylooper.v1.PrivateInfo.IncidentsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	17, // 25: tragedylooper.v1.PublicInfo.SpecialIncidentsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	17, // 26: tragedylooper.v1.PublicInfo.ScheduledIncidentsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	21, // 27: tragedylooper.v1.RoleConfig.AbilitiesEntry.value:type_name -> tragedylooper.v1.AbilityConfig
	17, // 28: tragedylooper.v1.PlotConfig.IncidentIdsEntry.value:type_name -> tragedylooper.v1.IncidentConfig
	0,  // 29: tragedylooper.v1.ScriptConfigLib.ScriptsEntry.value:type_name -> tragedylooper.v1.ScriptConfig
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_tragedylooper_v1_script_proto_init() }
func file_tragedylooper_v1_script_proto_init() {
	if File_tragedylooper_v1_script_proto != nil {
		return
	}
	file_tragedylooper_v1_condition_proto_init()
	file_tragedylooper_v1_effect_proto_init()
	file_tragedylooper_v1_enums_proto_init()
	file_tragedylooper_v1_incident_proto_init()
	file_tragedylooper_v1_character_proto_init()
	file_tragedylooper_v1_card_proto_init()
	file_tragedylooper_v1_ability_proto_init()
	file_tragedylooper_v1_script_proto_msgTypes[1].OneofWrappers = []any{
		(*ScriptEntity_MainPlot)(nil),
		(*ScriptEntity_SubPlot)(nil),
		(*ScriptEntity_Role)(nil),
		(*ScriptEntity_Incident)(nil),
		(*ScriptEntity_Character)(nil),
		(*ScriptEntity_MastermindCard)(nil),
		(*ScriptEntity_ProtagonistCard)(nil),
		(*ScriptEntity_ScriptModel)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tragedylooper_v1_script_proto_rawDesc), len(file_tragedylooper_v1_script_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tragedylooper_v1_script_proto_goTypes,
		DependencyIndexes: file_tragedylooper_v1_script_proto_depIdxs,
		MessageInfos:      file_tragedylooper_v1_script_proto_msgTypes,
	}.Build()
	File_tragedylooper_v1_script_proto = out.File
	file_tragedylooper_v1_script_proto_goTypes = nil
	file_tragedylooper_v1_script_proto_depIdxs = nil
}
