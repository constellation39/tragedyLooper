// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: tragedylooper/v1/event.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GameEvent with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GameEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GameEventMultiError, or nil
// if none found.
func (m *GameEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *GameEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GameEventValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GameEventValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GameEventValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GameEventValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GameEventValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GameEventValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Cause != nil {

		if all {
			switch v := interface{}(m.GetCause()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GameEventValidationError{
						field:  "Cause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GameEventValidationError{
						field:  "Cause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCause()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GameEventValidationError{
					field:  "Cause",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GameEventMultiError(errors)
	}

	return nil
}

// GameEventMultiError is an error wrapping multiple validation errors returned
// by GameEvent.ValidateAll() if the designated constraints aren't met.
type GameEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameEventMultiError) AllErrors() []error { return m }

// GameEventValidationError is the validation error returned by
// GameEvent.Validate if the designated constraints aren't met.
type GameEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameEventValidationError) ErrorName() string { return "GameEventValidationError" }

// Error satisfies the builtin error interface
func (e GameEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameEventValidationError{}

// Validate checks the field values on Cause with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cause) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cause with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CauseMultiError, or nil if none found.
func (m *Cause) ValidateAll() error {
	return m.validate(true)
}

func (m *Cause) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.CauseType.(type) {
	case *Cause_CardId:
		if v == nil {
			err := CauseValidationError{
				field:  "CauseType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for CardId
	case *Cause_AbilityId:
		if v == nil {
			err := CauseValidationError{
				field:  "CauseType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for AbilityId
	case *Cause_IncidentId:
		if v == nil {
			err := CauseValidationError{
				field:  "CauseType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for IncidentId
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CauseMultiError(errors)
	}

	return nil
}

// CauseMultiError is an error wrapping multiple validation errors returned by
// Cause.ValidateAll() if the designated constraints aren't met.
type CauseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CauseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CauseMultiError) AllErrors() []error { return m }

// CauseValidationError is the validation error returned by Cause.Validate if
// the designated constraints aren't met.
type CauseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CauseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CauseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CauseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CauseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CauseValidationError) ErrorName() string { return "CauseValidationError" }

// Error satisfies the builtin error interface
func (e CauseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCause.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CauseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CauseValidationError{}

// Validate checks the field values on EventPayload with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EventPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventPayload with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EventPayloadMultiError, or
// nil if none found.
func (m *EventPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *EventPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *EventPayload_CharacterMoved:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCharacterMoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "CharacterMoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "CharacterMoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCharacterMoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "CharacterMoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_StatAdjusted:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStatAdjusted()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "StatAdjusted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "StatAdjusted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStatAdjusted()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "StatAdjusted",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_LoopLoss:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoopLoss()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "LoopLoss",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "LoopLoss",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoopLoss()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "LoopLoss",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_LoopWin:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoopWin()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "LoopWin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "LoopWin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoopWin()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "LoopWin",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_AbilityUsed:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAbilityUsed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "AbilityUsed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "AbilityUsed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAbilityUsed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "AbilityUsed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_DayAdvanced:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDayAdvanced()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "DayAdvanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "DayAdvanced",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDayAdvanced()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "DayAdvanced",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_CardPlayed:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCardPlayed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "CardPlayed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "CardPlayed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCardPlayed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "CardPlayed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_CardRevealed:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCardRevealed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "CardRevealed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "CardRevealed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCardRevealed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "CardRevealed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_LoopReset:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoopReset()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "LoopReset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "LoopReset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoopReset()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "LoopReset",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_GameEnded:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGameEnded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "GameEnded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "GameEnded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGameEnded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "GameEnded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_ChoiceRequired:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetChoiceRequired()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "ChoiceRequired",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "ChoiceRequired",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetChoiceRequired()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "ChoiceRequired",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_IncidentTriggered:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIncidentTriggered()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "IncidentTriggered",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "IncidentTriggered",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIncidentTriggered()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "IncidentTriggered",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_TragedyTriggered:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTragedyTriggered()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "TragedyTriggered",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "TragedyTriggered",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTragedyTriggered()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "TragedyTriggered",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_TraitAdjusted:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTraitAdjusted()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "TraitAdjusted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "TraitAdjusted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTraitAdjusted()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "TraitAdjusted",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventPayload_PlayerActionTaken:
		if v == nil {
			err := EventPayloadValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPlayerActionTaken()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "PlayerActionTaken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventPayloadValidationError{
						field:  "PlayerActionTaken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPlayerActionTaken()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventPayloadValidationError{
					field:  "PlayerActionTaken",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EventPayloadMultiError(errors)
	}

	return nil
}

// EventPayloadMultiError is an error wrapping multiple validation errors
// returned by EventPayload.ValidateAll() if the designated constraints aren't met.
type EventPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventPayloadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventPayloadMultiError) AllErrors() []error { return m }

// EventPayloadValidationError is the validation error returned by
// EventPayload.Validate if the designated constraints aren't met.
type EventPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventPayloadValidationError) ErrorName() string { return "EventPayloadValidationError" }

// Error satisfies the builtin error interface
func (e EventPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventPayloadValidationError{}

// Validate checks the field values on CharacterMovedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CharacterMovedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharacterMovedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CharacterMovedEventMultiError, or nil if none found.
func (m *CharacterMovedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *CharacterMovedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CharacterId

	// no validation rules for NewLocation

	if len(errors) > 0 {
		return CharacterMovedEventMultiError(errors)
	}

	return nil
}

// CharacterMovedEventMultiError is an error wrapping multiple validation
// errors returned by CharacterMovedEvent.ValidateAll() if the designated
// constraints aren't met.
type CharacterMovedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharacterMovedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharacterMovedEventMultiError) AllErrors() []error { return m }

// CharacterMovedEventValidationError is the validation error returned by
// CharacterMovedEvent.Validate if the designated constraints aren't met.
type CharacterMovedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharacterMovedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharacterMovedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharacterMovedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharacterMovedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharacterMovedEventValidationError) ErrorName() string {
	return "CharacterMovedEventValidationError"
}

// Error satisfies the builtin error interface
func (e CharacterMovedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharacterMovedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharacterMovedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharacterMovedEventValidationError{}

// Validate checks the field values on StatAdjustedEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StatAdjustedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatAdjustedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatAdjustedEventMultiError, or nil if none found.
func (m *StatAdjustedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *StatAdjustedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CharacterId

	// no validation rules for StatType

	// no validation rules for Amount

	// no validation rules for NewValue

	if len(errors) > 0 {
		return StatAdjustedEventMultiError(errors)
	}

	return nil
}

// StatAdjustedEventMultiError is an error wrapping multiple validation errors
// returned by StatAdjustedEvent.ValidateAll() if the designated constraints
// aren't met.
type StatAdjustedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatAdjustedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatAdjustedEventMultiError) AllErrors() []error { return m }

// StatAdjustedEventValidationError is the validation error returned by
// StatAdjustedEvent.Validate if the designated constraints aren't met.
type StatAdjustedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatAdjustedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatAdjustedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatAdjustedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatAdjustedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatAdjustedEventValidationError) ErrorName() string {
	return "StatAdjustedEventValidationError"
}

// Error satisfies the builtin error interface
func (e StatAdjustedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatAdjustedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatAdjustedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatAdjustedEventValidationError{}

// Validate checks the field values on TraitAdjustedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TraitAdjustedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraitAdjustedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TraitAdjustedEventMultiError, or nil if none found.
func (m *TraitAdjustedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TraitAdjustedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CharacterId

	// no validation rules for Trait

	// no validation rules for WasAdded

	if len(errors) > 0 {
		return TraitAdjustedEventMultiError(errors)
	}

	return nil
}

// TraitAdjustedEventMultiError is an error wrapping multiple validation errors
// returned by TraitAdjustedEvent.ValidateAll() if the designated constraints
// aren't met.
type TraitAdjustedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraitAdjustedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraitAdjustedEventMultiError) AllErrors() []error { return m }

// TraitAdjustedEventValidationError is the validation error returned by
// TraitAdjustedEvent.Validate if the designated constraints aren't met.
type TraitAdjustedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraitAdjustedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraitAdjustedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraitAdjustedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraitAdjustedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraitAdjustedEventValidationError) ErrorName() string {
	return "TraitAdjustedEventValidationError"
}

// Error satisfies the builtin error interface
func (e TraitAdjustedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraitAdjustedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraitAdjustedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraitAdjustedEventValidationError{}

// Validate checks the field values on LoopLossEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoopLossEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoopLossEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoopLossEventMultiError, or
// nil if none found.
func (m *LoopLossEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *LoopLossEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IncidentId

	if len(errors) > 0 {
		return LoopLossEventMultiError(errors)
	}

	return nil
}

// LoopLossEventMultiError is an error wrapping multiple validation errors
// returned by LoopLossEvent.ValidateAll() if the designated constraints
// aren't met.
type LoopLossEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoopLossEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoopLossEventMultiError) AllErrors() []error { return m }

// LoopLossEventValidationError is the validation error returned by
// LoopLossEvent.Validate if the designated constraints aren't met.
type LoopLossEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoopLossEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoopLossEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoopLossEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoopLossEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoopLossEventValidationError) ErrorName() string { return "LoopLossEventValidationError" }

// Error satisfies the builtin error interface
func (e LoopLossEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoopLossEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoopLossEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoopLossEventValidationError{}

// Validate checks the field values on LoopWinEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoopWinEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoopWinEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoopWinEventMultiError, or
// nil if none found.
func (m *LoopWinEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *LoopWinEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LoopWinEventMultiError(errors)
	}

	return nil
}

// LoopWinEventMultiError is an error wrapping multiple validation errors
// returned by LoopWinEvent.ValidateAll() if the designated constraints aren't met.
type LoopWinEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoopWinEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoopWinEventMultiError) AllErrors() []error { return m }

// LoopWinEventValidationError is the validation error returned by
// LoopWinEvent.Validate if the designated constraints aren't met.
type LoopWinEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoopWinEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoopWinEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoopWinEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoopWinEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoopWinEventValidationError) ErrorName() string { return "LoopWinEventValidationError" }

// Error satisfies the builtin error interface
func (e LoopWinEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoopWinEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoopWinEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoopWinEventValidationError{}

// Validate checks the field values on AbilityUsedEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AbilityUsedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AbilityUsedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AbilityUsedEventMultiError, or nil if none found.
func (m *AbilityUsedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *AbilityUsedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CharacterId

	// no validation rules for AbilityName

	if len(errors) > 0 {
		return AbilityUsedEventMultiError(errors)
	}

	return nil
}

// AbilityUsedEventMultiError is an error wrapping multiple validation errors
// returned by AbilityUsedEvent.ValidateAll() if the designated constraints
// aren't met.
type AbilityUsedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AbilityUsedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AbilityUsedEventMultiError) AllErrors() []error { return m }

// AbilityUsedEventValidationError is the validation error returned by
// AbilityUsedEvent.Validate if the designated constraints aren't met.
type AbilityUsedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AbilityUsedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AbilityUsedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AbilityUsedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AbilityUsedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AbilityUsedEventValidationError) ErrorName() string { return "AbilityUsedEventValidationError" }

// Error satisfies the builtin error interface
func (e AbilityUsedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAbilityUsedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AbilityUsedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AbilityUsedEventValidationError{}

// Validate checks the field values on DayAdvancedEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DayAdvancedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DayAdvancedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DayAdvancedEventMultiError, or nil if none found.
func (m *DayAdvancedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DayAdvancedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Day

	// no validation rules for Loop

	if len(errors) > 0 {
		return DayAdvancedEventMultiError(errors)
	}

	return nil
}

// DayAdvancedEventMultiError is an error wrapping multiple validation errors
// returned by DayAdvancedEvent.ValidateAll() if the designated constraints
// aren't met.
type DayAdvancedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DayAdvancedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DayAdvancedEventMultiError) AllErrors() []error { return m }

// DayAdvancedEventValidationError is the validation error returned by
// DayAdvancedEvent.Validate if the designated constraints aren't met.
type DayAdvancedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DayAdvancedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DayAdvancedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DayAdvancedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DayAdvancedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DayAdvancedEventValidationError) ErrorName() string { return "DayAdvancedEventValidationError" }

// Error satisfies the builtin error interface
func (e DayAdvancedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDayAdvancedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DayAdvancedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DayAdvancedEventValidationError{}

// Validate checks the field values on CardPlayedEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CardPlayedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardPlayedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardPlayedEventMultiError, or nil if none found.
func (m *CardPlayedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *CardPlayedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlayerId

	if all {
		switch v := interface{}(m.GetCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardPlayedEventValidationError{
					field:  "Card",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardPlayedEventValidationError{
					field:  "Card",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardPlayedEventValidationError{
				field:  "Card",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CardPlayedEventMultiError(errors)
	}

	return nil
}

// CardPlayedEventMultiError is an error wrapping multiple validation errors
// returned by CardPlayedEvent.ValidateAll() if the designated constraints
// aren't met.
type CardPlayedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardPlayedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardPlayedEventMultiError) AllErrors() []error { return m }

// CardPlayedEventValidationError is the validation error returned by
// CardPlayedEvent.Validate if the designated constraints aren't met.
type CardPlayedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardPlayedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardPlayedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardPlayedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardPlayedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardPlayedEventValidationError) ErrorName() string { return "CardPlayedEventValidationError" }

// Error satisfies the builtin error interface
func (e CardPlayedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardPlayedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardPlayedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardPlayedEventValidationError{}

// Validate checks the field values on CardRevealedEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CardRevealedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardRevealedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardRevealedEventMultiError, or nil if none found.
func (m *CardRevealedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *CardRevealedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int32, len(m.GetCards()))
		i := 0
		for key := range m.GetCards() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCards()[key]
			_ = val

			// no validation rules for Cards[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CardRevealedEventValidationError{
							field:  fmt.Sprintf("Cards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CardRevealedEventValidationError{
							field:  fmt.Sprintf("Cards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CardRevealedEventValidationError{
						field:  fmt.Sprintf("Cards[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return CardRevealedEventMultiError(errors)
	}

	return nil
}

// CardRevealedEventMultiError is an error wrapping multiple validation errors
// returned by CardRevealedEvent.ValidateAll() if the designated constraints
// aren't met.
type CardRevealedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardRevealedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardRevealedEventMultiError) AllErrors() []error { return m }

// CardRevealedEventValidationError is the validation error returned by
// CardRevealedEvent.Validate if the designated constraints aren't met.
type CardRevealedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardRevealedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardRevealedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardRevealedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardRevealedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardRevealedEventValidationError) ErrorName() string {
	return "CardRevealedEventValidationError"
}

// Error satisfies the builtin error interface
func (e CardRevealedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardRevealedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardRevealedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardRevealedEventValidationError{}

// Validate checks the field values on LoopResetEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoopResetEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoopResetEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoopResetEventMultiError,
// or nil if none found.
func (m *LoopResetEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *LoopResetEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LoopNumber

	if len(errors) > 0 {
		return LoopResetEventMultiError(errors)
	}

	return nil
}

// LoopResetEventMultiError is an error wrapping multiple validation errors
// returned by LoopResetEvent.ValidateAll() if the designated constraints
// aren't met.
type LoopResetEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoopResetEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoopResetEventMultiError) AllErrors() []error { return m }

// LoopResetEventValidationError is the validation error returned by
// LoopResetEvent.Validate if the designated constraints aren't met.
type LoopResetEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoopResetEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoopResetEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoopResetEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoopResetEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoopResetEventValidationError) ErrorName() string { return "LoopResetEventValidationError" }

// Error satisfies the builtin error interface
func (e LoopResetEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoopResetEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoopResetEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoopResetEventValidationError{}

// Validate checks the field values on GameEndedEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GameEndedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameEndedEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GameEndedEventMultiError,
// or nil if none found.
func (m *GameEndedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *GameEndedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Winner

	// no validation rules for Reason

	if len(errors) > 0 {
		return GameEndedEventMultiError(errors)
	}

	return nil
}

// GameEndedEventMultiError is an error wrapping multiple validation errors
// returned by GameEndedEvent.ValidateAll() if the designated constraints
// aren't met.
type GameEndedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameEndedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameEndedEventMultiError) AllErrors() []error { return m }

// GameEndedEventValidationError is the validation error returned by
// GameEndedEvent.Validate if the designated constraints aren't met.
type GameEndedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameEndedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameEndedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameEndedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameEndedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameEndedEventValidationError) ErrorName() string { return "GameEndedEventValidationError" }

// Error satisfies the builtin error interface
func (e GameEndedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameEndedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameEndedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameEndedEventValidationError{}

// Validate checks the field values on ChoiceRequiredEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChoiceRequiredEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChoiceRequiredEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChoiceRequiredEventMultiError, or nil if none found.
func (m *ChoiceRequiredEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ChoiceRequiredEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for PlayerId

	for idx, item := range m.GetChoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChoiceRequiredEventValidationError{
						field:  fmt.Sprintf("Choices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChoiceRequiredEventValidationError{
						field:  fmt.Sprintf("Choices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChoiceRequiredEventValidationError{
					field:  fmt.Sprintf("Choices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChoiceRequiredEventMultiError(errors)
	}

	return nil
}

// ChoiceRequiredEventMultiError is an error wrapping multiple validation
// errors returned by ChoiceRequiredEvent.ValidateAll() if the designated
// constraints aren't met.
type ChoiceRequiredEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChoiceRequiredEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChoiceRequiredEventMultiError) AllErrors() []error { return m }

// ChoiceRequiredEventValidationError is the validation error returned by
// ChoiceRequiredEvent.Validate if the designated constraints aren't met.
type ChoiceRequiredEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChoiceRequiredEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChoiceRequiredEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChoiceRequiredEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChoiceRequiredEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChoiceRequiredEventValidationError) ErrorName() string {
	return "ChoiceRequiredEventValidationError"
}

// Error satisfies the builtin error interface
func (e ChoiceRequiredEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChoiceRequiredEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChoiceRequiredEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChoiceRequiredEventValidationError{}

// Validate checks the field values on IncidentTriggeredEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IncidentTriggeredEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncidentTriggeredEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IncidentTriggeredEventMultiError, or nil if none found.
func (m *IncidentTriggeredEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *IncidentTriggeredEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIncident()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncidentTriggeredEventValidationError{
					field:  "Incident",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncidentTriggeredEventValidationError{
					field:  "Incident",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncident()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncidentTriggeredEventValidationError{
				field:  "Incident",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IncidentTriggeredEventMultiError(errors)
	}

	return nil
}

// IncidentTriggeredEventMultiError is an error wrapping multiple validation
// errors returned by IncidentTriggeredEvent.ValidateAll() if the designated
// constraints aren't met.
type IncidentTriggeredEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncidentTriggeredEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncidentTriggeredEventMultiError) AllErrors() []error { return m }

// IncidentTriggeredEventValidationError is the validation error returned by
// IncidentTriggeredEvent.Validate if the designated constraints aren't met.
type IncidentTriggeredEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncidentTriggeredEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncidentTriggeredEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncidentTriggeredEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncidentTriggeredEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncidentTriggeredEventValidationError) ErrorName() string {
	return "IncidentTriggeredEventValidationError"
}

// Error satisfies the builtin error interface
func (e IncidentTriggeredEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncidentTriggeredEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncidentTriggeredEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncidentTriggeredEventValidationError{}

// Validate checks the field values on TragedyTriggeredEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TragedyTriggeredEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TragedyTriggeredEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TragedyTriggeredEventMultiError, or nil if none found.
func (m *TragedyTriggeredEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TragedyTriggeredEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TragedyId

	if len(errors) > 0 {
		return TragedyTriggeredEventMultiError(errors)
	}

	return nil
}

// TragedyTriggeredEventMultiError is an error wrapping multiple validation
// errors returned by TragedyTriggeredEvent.ValidateAll() if the designated
// constraints aren't met.
type TragedyTriggeredEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TragedyTriggeredEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TragedyTriggeredEventMultiError) AllErrors() []error { return m }

// TragedyTriggeredEventValidationError is the validation error returned by
// TragedyTriggeredEvent.Validate if the designated constraints aren't met.
type TragedyTriggeredEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TragedyTriggeredEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TragedyTriggeredEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TragedyTriggeredEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TragedyTriggeredEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TragedyTriggeredEventValidationError) ErrorName() string {
	return "TragedyTriggeredEventValidationError"
}

// Error satisfies the builtin error interface
func (e TragedyTriggeredEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTragedyTriggeredEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TragedyTriggeredEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TragedyTriggeredEventValidationError{}

// Validate checks the field values on PlayerActionTakenEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PlayerActionTakenEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerActionTakenEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PlayerActionTakenEventMultiError, or nil if none found.
func (m *PlayerActionTakenEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerActionTakenEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlayerId

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlayerActionTakenEventValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlayerActionTakenEventValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlayerActionTakenEventValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PlayerActionTakenEventMultiError(errors)
	}

	return nil
}

// PlayerActionTakenEventMultiError is an error wrapping multiple validation
// errors returned by PlayerActionTakenEvent.ValidateAll() if the designated
// constraints aren't met.
type PlayerActionTakenEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerActionTakenEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerActionTakenEventMultiError) AllErrors() []error { return m }

// PlayerActionTakenEventValidationError is the validation error returned by
// PlayerActionTakenEvent.Validate if the designated constraints aren't met.
type PlayerActionTakenEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerActionTakenEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerActionTakenEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerActionTakenEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerActionTakenEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerActionTakenEventValidationError) ErrorName() string {
	return "PlayerActionTakenEventValidationError"
}

// Error satisfies the builtin error interface
func (e PlayerActionTakenEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerActionTakenEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerActionTakenEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerActionTakenEventValidationError{}
